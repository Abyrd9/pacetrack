#!/usr/bin/env bun

import { readdir, readFile, stat, writeFile } from "node:fs/promises";
import { extname, join } from "node:path";

type RouteInfo = {
  name: string;
  type: string;
  relativeImportPath: string;
  fullPath: string;
};

async function findRouteSchemaFiles(dir: string): Promise<string[]> {
  const files: string[] = [];

  async function scan(currentDir: string) {
    const entries = await readdir(currentDir);

    for (const entry of entries) {
      const fullPath = join(currentDir, entry);
      const stats = await stat(fullPath);

      if (stats.isDirectory()) {
        await scan(fullPath);
      } else if (
        stats.isFile() &&
        extname(entry) === ".ts" &&
        entry !== "index.ts"
      ) {
        files.push(fullPath);
      }
    }
  }

  await scan(dir);
  return files;
}

function formatGeneratedCode(imports: string[], definitions: string[]): string {
  // Imports and definitions are already sorted alphabetically
  // Format with consistent spacing for clean, readable output
  const formattedImports = imports.map((imp) => imp).join("\n");
  const formattedDefinitions = definitions.map((def) => def).join("\n");

  return `/** biome-ignore-all assist/source/organizeImports: We don't want this for this file */

// Auto-generated by scripts/generate-route-definitions.ts
// Do not edit manually

${formattedImports}

export const ROUTE_DEFINITIONS = {
${formattedDefinitions}
};
`;
}

async function analyzeRouteFile(path: string): Promise<RouteInfo | null> {
  const content = await readFile(path, "utf-8");
  const relativeImportPath = path
    .replace(/.*\/routes-schema\//, "./")
    .replace(/\.ts$/, "");

  // Extract route constant name (ending with _ROUTE)
  const routeConstantMatch = content.match(/export const (\w+_ROUTE)\s*=/);
  if (!routeConstantMatch) {
    console.error(`âŒ No _ROUTE constant found in ${path}`);
    return null;
  }

  // Extract route response type name (ending with RouteResponse)
  const routeResponseMatch = content.match(
    /export type (\w+RouteResponse)\s*=/
  );
  if (!routeResponseMatch) {
    console.error(`âŒ No RouteResponse type found in ${path}`);
    return null;
  }

  return {
    name: routeConstantMatch[1],
    type: routeResponseMatch[1],
    relativeImportPath: relativeImportPath,
    fullPath: path,
  };
}

async function generateRouteDefinitions() {
  console.log("ðŸ” Scanning routes-schema directory...");

  const routesSchemaDir = join(process.cwd(), "src", "routes-schema");
  const routeSchemaFiles = await findRouteSchemaFiles(routesSchemaDir);

  console.log(`ðŸ“ Found ${routeSchemaFiles.length} route schema files`);

  const routeInfos: RouteInfo[] = [];

  for (const routeSchemaFilePath of routeSchemaFiles) {
    const routeInfo = await analyzeRouteFile(routeSchemaFilePath);
    if (routeInfo) {
      routeInfos.push(routeInfo);
    }
  }

  if (routeInfos.length === 0) {
    console.error("âŒ No valid route files found!");
    return;
  }

  console.log(`âœ… Found ${routeInfos.length} valid route files`);

  // Generate import statements (already sorted)
  const imports = routeInfos
    .map((info) => `import { ${info.name} } from "${info.relativeImportPath}";`)
    .sort();

  // Generate ROUTE_DEFINITIONS object (already sorted)
  const definitions = routeInfos
    .map((info) => `  ${info.name}: ${info.name},`)
    .sort();

  // Format the generated code
  const output = formatGeneratedCode(imports, definitions);

  const indexPath = join(routesSchemaDir, "index.ts");

  await writeFile(indexPath, output, "utf-8");

  console.log(
    `ðŸ“ Generated ROUTE_DEFINITIONS with ${routeInfos.length} routes`
  );
  console.log(`ðŸ’¾ Updated ${indexPath}`);

  // Summary
  console.log("\nðŸ“Š Summary:");
  routeInfos.forEach((info) => {
    console.log(`  âœ… ${info.name} (${info.relativeImportPath})`);
  });
}

async function main() {
  try {
    await generateRouteDefinitions();
    console.log("\nðŸŽ‰ Route definitions generated successfully!");
  } catch (error) {
    console.error("ðŸ’¥ Error generating route definitions:", error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main();
}

export { generateRouteDefinitions };
